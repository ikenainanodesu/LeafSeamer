# LeafSeamer 项目运行逻辑分析

## 1. 概述

本文档分析 LeafSeamer 项目的运行逻辑,包括启动流程、数据流转、模块间通信机制等。

**分析时间**: 2025-12-17  
**NodeCG 版本**: 2.6.4

---

## 2. 项目启动流程

### 2.1 启动命令

```bash
npm run dev  # 或 npm start
# 执行 nodecg start
```

### 2.2 NodeCG 启动过程

```
1. NodeCG 服务器启动
   ├── 扫描 bundles/ 目录
   ├── 加载各 bundle 的 package.json
   └── 读取 nodecg 配置

2. Extension 加载阶段
   ├── 加载 bundles/*/extension/index.js
   ├── 执行各 bundle 的 module.exports 函数
   └── 传入 nodecg.ServerAPI 实例

3. Dashboard/Graphics 服务
   ├── 提供静态文件服务
   ├── 服务 dashboard/*.html
   └── 服务 graphics/*.html

4. WebSocket 连接
   ├── 建立 Browser ↔ Server 双向通信
   └── Replicants 自动同步
```

### 2.3 各 Bundle Extension 初始化顺序

由于 NodeCG 的并发加载机制,bundle 加载顺序不确定,但有以下特点:

1. **logger-system** - 设计为首先可用,暴露日志 API
2. **其他 bundles** - 可以在任意时刻调用 logger-system API

**典型初始化流程**:

```typescript
// 以 mixer-control 为例
module.exports = function (nodecg: NodeCG.ServerAPI) {
  // 1. 创建 logger
  const logger = createLogger("MixerControl");
  logger.setNodeCG(nodecg);

  // 2. 初始化 Replicants (持久化状态)
  nodecg.Replicant<MixerConnectionSettings>("mixerConnectionSettings", {
    defaultValue: { ip: "127.0.0.1", port: "8000", protocol: "udp" },
  });

  // 3. 创建管理器实例
  const stateManager = new StateManager(nodecg);
  const connectionManager = new ConnectionManager(nodecg, stateManager);

  // 4. 注册消息监听器
  nodecg.listenFor("connectMixer", (data) => {
    connectionManager.connect(data);
  });

  // 5. 可选:暴露 API 给其他 bundles
  // return { ... };
};
```

---

## 3. 核心数据流分析

### 3.1 Replicants 状态管理

Replicants 是 NodeCG 的核心概念,提供:

- **Browser ↔ Server 自动同步**
- **持久化存储** (保存在 db/ 目录)
- **事件驱动的变更通知**

**主要 Replicants 清单**:

| Bundle            | Replicant Name          | 类型                     | 用途         |
| ----------------- | ----------------------- | ------------------------ | ------------ |
| seamer            | seamerCards             | SeamerCard[]             | 卡片配置     |
| mixer-control     | mixerConnectionSettings | MixerConnectionSettings  | 连接配置     |
| mixer-control     | mixerState              | MixerState               | 混音器状态   |
| obs-control       | obsConnections          | OBSConnectionSettings[]  | OBS 连接配置 |
| obs-control       | obsStates               | Record<string, OBSState> | 各 OBS 状态  |
| vb-matrix-control | networkConfig           | NetworkConfig            | 网络配置     |
| vb-matrix-control | activePatches           | CurrentPatchStatus[]     | 激活的 patch |
| vb-matrix-control | presets                 | Preset[]                 | 预设列表     |
| vb-matrix-control | hostInfo                | { localIPs: string[] }   | 主机信息     |
| logger-system     | logs                    | LogEntry[]               | 日志条目     |
| backup-system     | backupList              | BackupFile[]             | 备份文件列表 |

### 3.2 跨 Bundle 数据访问

**示例:seamer 访问其他 bundle 的状态**

```typescript
// seamer/src/dashboard/App.tsx

// 访问 mixer-control 的状态
const mixerRep = nodecg.Replicant<MixerState>("mixerState", "mixer-control");
mixerRep.on("change", (newVal) => setMixerState(newVal || null));

// 访问 vb-matrix-control 的预设
const presetsRep = nodecg.Replicant<Preset[]>("presets", "vb-matrix-control");
presetsRep.on("change", (newVal) => setPresets(newVal || []));

// 访问 obs-control 的连接配置
const obsConRep = nodecg.Replicant<OBSConnectionSettings[]>(
  "obsConnections",
  "obs-control"
);
obsConRep.on("change", (newVal) => setObsConnections(newVal || []));

// 访问 obs-control 的状态
const obsStateRep = nodecg.Replicant<Record<string, OBSState>>(
  "obsStates",
  "obs-control"
);
obsStateRep.on("change", (newVal) => setObsStates(newVal || {}));
```

---

## 4. 消息通信机制

### 4.1 Browser → Server 消息

**格式**:

```typescript
nodecg.sendMessageToBundle(messageName, bundleName, data);
```

**示例:seamer 控制其他 bundles**

```typescript
// seamer/src/dashboard/App.tsx - runCard 函数

// 1. 控制 Mixer 推子
nodecg.sendMessageToBundle("setMixerFader", "mixer-control", {
  channelId: action.channelId,
  level: action.level,
});

// 2. 加载 VB Matrix 预设
nodecg.sendMessageToBundle("loadPreset", "vb-matrix-control", action.presetId);

// 3. 设置 OBS 场景
nodecg.sendMessageToBundle("setOBSScene", "obs-control", {
  id: action.connectionId,
  scene: action.sceneName,
});

// 4. 设置 OBS 转场
nodecg.sendMessageToBundle("setOBSTransition", "obs-control", {
  id: action.connectionId,
  transition: action.transitionName,
});
```

### 4.2 Server 消息监听

**格式**:

```typescript
nodecg.listenFor(messageName, callback);
```

**示例:mixer-control 监听控制消息**

```typescript
// mixer-control/extension/index.ts

nodecg.listenFor(
  "connectMixer",
  (data: { ip: string; port: number; protocol: "udp" | "tcp" }) => {
    connectionManager.connect(data);
  }
);

nodecg.listenFor("disconnectMixer", () => {
  connectionManager.disconnect();
});

nodecg.listenFor(
  "setMixerFader",
  (data: { channelId: number; level: number }) => {
    connectionManager.setFaderLevel(data.channelId, data.level);
  }
);

nodecg.listenFor(
  "setMixerMute",
  (data: { channelId: number; isMuted: boolean }) => {
    connectionManager.setMute(data.channelId, data.isMuted);
  }
);
```

---

## 5. 各 Bundle 运行逻辑详解

### 5.1 mixer-control 运行逻辑

```
用户操作 (Dashboard)
    ↓
修改连接配置 → Replicant Updated
    ↓
点击 "Connect" → sendMessage('connectMixer')
    ↓
Extension 接收消息
    ↓
ConnectionManager.connect()
    ├── 创建 OSC Client (UDP/TCP)
    ├── 发送初始化查询指令
    └── 启动消息监听

OSC 设备响应
    ↓
ConnectionManager 接收 OSC 消息
    ↓
解析 OSC 地址和参数
    ↓
StateManager 更新状态
    ├── 解析通道参数 (/ch/01/mix/fader, /ch/01/mix/on等)
    ├── 解析输出参数 (/bus/*/mix/fader等)
    └── 更新 mixerState Replicant

Replicant 变更触发
    ↓
Dashboard 自动更新 UI
    └── 推子、静音按钮、路由信息同步显示
```

**关键类**:

- `ConnectionManager` - OSC 连接管理
- `StateManager` - 状态解析和更新

### 5.2 obs-control 运行逻辑

```
Extension 启动
    ↓
ConnectionManager.connectAll()
    ├── 遍历 obsConnections Replicant
    ├── 为每个配置创建 OBSWebSocket 实例
    └── 建立 WebSocket 连接

连接成功
    ↓
SceneManager 查询 OBS 状态
    ├── GetSceneList
    ├── GetCurrentProgramScene
    ├── GetTransitionList
    └── GetStreamStatus

接收 OBS 事件
    ├── CurrentProgramSceneChanged
    ├── StreamStateChanged
    ├── RecordStateChanged
    └── StreamStats (定时更新)
        ↓
更新 obsStates[connectionId] Replicant
        ↓
Dashboard UI 自动同步

用户操作 (Dashboard 或 Seamer)
    ↓
sendMessage('setOBSScene', { id, scene })
    ↓
Extension 接收
    ↓
SceneManager.setScene()
    ↓
发送 SetCurrentProgramScene 到 OBS
    ↓
OBS 执行场景切换
    ↓
接收 CurrentProgramSceneChanged 事件
    ↓
更新 Replicant
    ↓
UI 反馈
```

**关键特性**:

- **多实例管理** - 支持多个 OBS 连接
- **自动重连** - 连接断开后自动重试
- **实时统计** - 流状态监控 (FPS, 码率等)

### 5.3 vb-matrix-control 运行逻辑

```
Extension 启动
    ↓
MatrixManager 初始化
    ├── 加载预设文件 (presets.json)
    ├── 创建 VBANTransmitter
    └── 注册消息监听器

用户配置网络
    ↓
设置 IP/Port → 更新 networkConfig Replicant
    ↓
Ping Test
    ├── 发送 VBAN 协议 "PING" 命令
    ├── 监听 UDP 响应 (11111端口)
    └── 解析设备信息

用户选择 Patch
    ↓
选择 Input/Output 设备
    ↓
sendMessage('setPatch', { input, output, slot })
    ↓
Extension 接收
    ↓
VBANTransmitter 发送 VBAN 命令
    └── Strip.Device.WDM / Bus.Device.WDM

用户保存预设
    ↓
sendMessage('savePreset', { name, patches })
    ↓
Extension 保存到 presets Replicant
    ↓
持久化到文件 (bundle_root/presets.json)

用户加载预设 (从 seamer 或本地)
    ↓
sendMessage('loadPreset', presetId)
    ↓
Extension 查找预设
    ↓
依次应用所有 patches
    └── 发送多个 VBAN 命令
```

**关键组件**:

- `MatrixManager` - 核心管理逻辑 (609行)
- `VBANTransmitter` - VBAN 协议发送器
- 持久化机制 - 预设保存到 JSON 文件

### 5.4 seamer 运行逻辑

```
Dashboard 加载
    ↓
App 组件初始化
    ├── 订阅 seamerCards Replicant (本地卡片)
    ├── 订阅 mixerState (mixer-control)
    ├── 订阅 presets (vb-matrix-control)
    ├── 订阅 obsConnections (obs-control)
    └── 订阅 obsStates (obs-control)

显示卡片网格
    ├── 遍历 cards 数组
    └── 渲染 Card 组件

用户点击 "Run" 按钮
    ↓
runCard(card) 函数
    ↓
遍历 card.actions
    ├── mixer-fader → sendMessageToBundle('setMixerFader')
    ├── vb-preset → sendMessageToBundle('loadPreset')
    └── obs-action → sendMessageToBundle('setOBSScene'/'setOBSTransition')
        ↓
对应 bundle 执行操作

用户拖放 JSON 文件
    ↓
handleDrop 事件
    ↓
解析 JSON
    ├── 验证格式 (title, actions 字段)
    ├── 生成新 UUID
    └── 添加到 seamerCards Replicant

用户编辑卡片
    ↓
打开 EditCardModal
    ├── 显示 Action 列表
    ├── 提供选择器 (Mixer 通道/VB 预设/OBS 场景)
    └── 保存到 Replicant
```

**卡片配置示例**:

```json
{
  "id": "uuid-here",
  "title": "开场配置",
  "actions": [
    {
      "id": "action-1",
      "type": "mixer-fader",
      "channelId": 1,
      "level": -10
    },
    {
      "id": "action-2",
      "type": "vb-preset",
      "presetId": "preset-uuid"
    },
    {
      "id": "action-3",
      "type": "obs-action",
      "connectionId": "default",
      "sceneName": "Scene 1",
      "transitionName": "Fade"
    }
  ]
}
```

### 5.5 logger-system 运行逻辑

```
Extension 启动
    ↓
暴露 API
    └── return { log: (level, category, message) => {...} }

其他 bundle 使用
    ↓
使用 shared/utils/logger.ts
    ↓
Logger.setNodeCG(nodecg)
    ↓
调用 logger.info/warn/error
    ↓
检查 nodecg.extensions['logger-system']
    ↓
调用 log API
    ↓
Extension 接收日志
    ├── 写入 logs Replicant
    └── 异步保存到文件 (Storage)

Dashboard 查看
    ↓
订阅 logs Replicant
    ↓
实时显示日志列表
    └── 支持过滤、搜索
```

**日志流向**:

```
Bundle Code → shared/utils/logger.ts → logger-system Extension → logs Replicant → Dashboard
```

### 5.6 backup-system 运行逻辑

```
用户点击 "Create Backup"
    ↓
sendMessage('createBackup')
    ↓
Extension 接收
    ↓
BackupManager.createBackup()
    ├── 创建 archiver 实例
    ├── 压缩 cfg/ 目录
    ├── 压缩 db/ 目录
    └── 输出到 backups/backup-[timestamp].zip
        ↓
完成后 refreshBackupList()
    ↓
更新 backupList Replicant
    ↓
Dashboard 显示备份列表
```

**备份内容**:

- `cfg/` - NodeCG 配置
- `db/` - Replicants 持久化数据

---

## 6. 完整数据流图

```
┌─────────────────────────────────────────────────────────────┐
│                       Browser (Dashboard)                    │
├─────────────────────────────────────────────────────────────┤
│  seamer          mixer-control    obs-control    vb-matrix  │
│  Dashboard       Dashboard        Dashboard      Dashboard  │
│                                                              │
│  ┌──────────┐   ┌──────────┐    ┌──────────┐  ┌──────────┐│
│  │  Cards   │   │ Faders   │    │ Scenes   │  │ Patches  ││
│  │  Grid    │   │ Meters   │    │ Buttons  │  │ Presets  ││
│  └─────┬────┘   └────┬─────┘    └────┬─────┘  └────┬─────┘│
└────────┼─────────────┼───────────────┼─────────────┼───────┘
         │             │               │             │
         │   WebSocket Connection (NodeCG)           │
         │             │               │             │
┌────────┼─────────────┼───────────────┼─────────────┼───────┐
│        ▼             ▼               ▼             ▼       │
│  ┌─────────────────────────────────────────────────────┐  │
│  │           NodeCG Replicants (Shared State)          │  │
│  │  - seamerCards  - mixerState  - obsStates - presets │  │
│  └─────────────────────────────────────────────────────┘  │
│                                                            │
│  ┌─────────────────────────────────────────────────────┐  │
│  │        NodeCG Messages (Command Channel)             │  │
│  │  sendMessageToBundle / listenFor                     │  │
│  └─────────────────────────────────────────────────────┘  │
│                                                            │
│                  NodeCG Server (Extensions)               │
├────────────────────────────────────────────────────────────┤
│  seamer Ext    mixer Ext      obs Ext       vb Ext         │
│  (minimal)     OSC Client     WebSocket     VBAN Client    │
│                                                            │
└────────┬─────────────┬───────────────┬─────────────┬───────┘
         │             │               │             │
         │             ▼               ▼             ▼
         │      ┌──────────┐   ┌──────────┐  ┌──────────┐
         │      │  Mixer   │   │   OBS    │  │VB Matrix │
         │      │  OSC     │   │WebSocket │  │  VBAN    │
         │      │ :8000    │   │  :4455   │  │  :6980   │
         │      └──────────┘   └──────────┘  └──────────┘
         │
         └──── (协调其他 bundles 的操作)
```

---

## 7. 关键交互场景

### 场景 1: 用户从 Seamer 执行一键操作

```
1. 用户在 Seamer Dashboard 点击 "开场" 卡片的 Run 按钮
   ↓
2. seamer App.tsx runCard() 函数执行
   ↓
3. 遍历卡片中的 3 个 actions:

   Action 1 (mixer-fader):
   - sendMessageToBundle('setMixerFader', 'mixer-control', {channelId: 1, level: -10})
   - mixer-control Extension 接收
   - ConnectionManager 发送 OSC 命令到 Mixer
   - '/ch/01/mix/fader 0.75' (OSC)
   - Mixer 执行,发送状态回传
   - StateManager 更新 mixerState Replicant
   - mixer-control Dashboard 推子 UI 更新

   Action 2 (vb-preset):
   - sendMessageToBundle('loadPreset', 'vb-matrix-control', 'preset-uuid')
   - vb-matrix-control Extension 接收
   - MatrixManager 查找预设
   - 遍历预设中的 patches
   - VBANTransmitter 发送多个 VBAN 命令
   - VB Matrix 执行音频路由切换

   Action 3 (obs-action):
   - sendMessageToBundle('setOBSTransition', 'obs-control', {id: 'default', transition: 'Fade'})
   - sendMessageToBundle('setOBSScene', 'obs-control', {id: 'default', scene: 'Scene 1'})
   - obs-control Extension 接收
   - SceneManager 发送 SetCurrentProgramScene 到 OBS WebSocket
   - OBS 执行场景切换
   - OBS 发送 CurrentProgramSceneChanged 事件
   - SceneManager 更新 obsStates Replicant
   - obs-control Dashboard UI 更新

4. 完成 - 所有设备状态已同步
```

### 场景 2: Mixer 状态变化传播

```
外部操作 Mixer 物理控制台
   ↓
Mixer 发送 OSC 消息
   ↓
mixer-control ConnectionManager 接收 OSC 消息
   例如: '/ch/01/mix/fader, f, 0.5'
   ↓
ConnectionManager 回调函数处理
   ↓
StateManager.updateChannelParameter()
   ├── 解析地址: /ch/01/mix/fader
   ├── 提取 channelId = 1
   ├── 转换值: OSC 0.0-1.0 → dB (-oo to +10)
   └── 更新 state.channels[0].faderLevel
   ↓
mixerState.value = newState (触发 Replicant 更新)
   ↓
WebSocket 推送到所有订阅的 Browser
   ↓
mixer-control Dashboard 组件 onChange 回调
   ↓
React setState 更新 UI
   └── 推子视觉位置同步
```

---

## 8. 性能考虑

### 8.1 Replicant 更新频率

高频 Replicant (如 mixerState) 可能每秒更新多次:

- OSC 消息频率: 可达数十次/秒 (推子移动时)
- WebSocket 传输: NodeCG 自动节流
- React 渲染: 使用 React.memo 优化

### 8.2 消息传递延迟

典型延迟链路:

```
Browser Click → WebSocket → Server → OSC/WebSocket → 设备
                 <10ms        <1ms      设备相关

设备 → Server → WebSocket → Browser Render
        <1ms      <10ms       <16ms (60fps)
```

总延迟: 通常 < 50ms (感知为即时)

### 8.3 内存占用

主要内存消耗:

- Replicants 持久化数据: < 1MB
- Logger 日志缓存: 可配置限制
- OBS WebSocket 连接: 每个 ~1MB

---

## 9. 错误处理机制

### 9.1 连接错误

**mixer-control**:

- OSC 连接失败 → 设置 `connected: false`
- 无响应超时 → 自动断开

**obs-control**:

- WebSocket 连接失败 → 重试机制 (3次,间隔2秒)
- 密码错误 → 返回错误状态
- 连接断开 → 自动重连

**vb-matrix-control**:

- VBAN 发送失败 → 静默失败 (UDP 无确认)
- Ping 超时 → UI 显示 "Fail"

### 9.2 数据验证

- Replicant 初始化提供 `defaultValue`
- 消息处理器检查数据类型
- 边界值检查 (推子范围、ID 有效性等)

---

## 10. 扩展性分析

### 10.1 添加新 Bundle

步骤:

1. 创建 bundle 目录结构
2. 定义 package.json (nodecg 配置)
3. 实现 extension/index.ts (后端逻辑)
4. 实现 src/dashboard/\*.tsx (前端 UI)
5. 定义 Replicants 和消息接口
6. 构建 (Vite)

### 10.2 与 Seamer 集成

要让新 bundle 可被 seamer 控制:

1. 定义明确的消息接口
2. 在 seamer.types.ts 添加新 ActionType
3. 在 seamer EditCardModal 添加 UI 选择器
4. 在 seamer App.tsx runCard 添加执行逻辑

---

## 11. 总结

LeafSeamer 的运行逻辑特点:

**优势**:

1. ✅ 事件驱动架构 - 响应式、低耦合
2. ✅ 自动状态同步 - Replicants 机制简化开发
3. ✅ 清晰的消息协议 - Bundle 间通信规范
4. ✅ 实时反馈 - WebSocket 双向通信
5. ✅ 扩展性强 - 易于添加新设备控制

**设计模式**:

- **发布-订阅**: Replicants 变更通知
- **命令模式**: NodeCG Messages
- **管理器模式**: ConnectionManager, StateManager 等

该项目的运行逻辑设计合理,充分利用了 NodeCG 框架的优势,实现了高效的设备控制和状态管理。
